import subprocess
from pathlib import Path
from subprocess import CompletedProcess

from datashuttle.configs.configs import Configs
from datashuttle.utils import utils


def call_rclone(command: str, pipe_std: bool = False) -> CompletedProcess:
    """
    Call rclone with the specified command. Current mode is double-verbose.
    Return the completed process from subprocess.

    Parameters
    ----------
    command: Rclone command to be run

    pipe_std: if True, do not output anything to stdout.
    """
    command = "rclone " + command
    if pipe_std:
        output = subprocess.run(
            command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True
        )
    else:
        output = subprocess.run(command, shell=True)

    return output


def handle_rclone_arguments(rclone_options):
    """
    Construct the extra arguments to pass to RClone based on the
    current configs.
    """
    extra_arguments_list = [rclone_args("create_empty_src_dirs")]

    extra_arguments_list += ["-" + rclone_options["transfer_verbosity"]]

    if not rclone_options["overwrite_old_files"]:
        extra_arguments_list += [rclone_args("ignore_existing")]

    if rclone_options["show_transfer_progress"]:
        extra_arguments_list += [rclone_args("progress")]

    if rclone_options["dry_run"]:
        extra_arguments_list += [rclone_args("dry_run")]

    if rclone_options["exclude_list"]:
        exclude_text = " --exclude "
        full_exclude_paths = [
            path_ + "/**" for path_ in rclone_options["exclude_list"]
        ]
        exclude_flags = (
            f"{exclude_text}{exclude_text.join(full_exclude_paths)}"
        )
        extra_arguments_list += [exclude_flags]

    extra_arguments = " ".join(extra_arguments_list)

    return extra_arguments


def transfer_data(
    local_filepath: str,
    remote_filepath: str,
    rclone_config_name: str,
    upload_or_download: str,
    rclone_options: dict,
) -> subprocess.CompletedProcess:
    """
    Call Rclone copy command with appropriate
    arguments to execute data transfer.

    Parameters
    ----------

    local_filepath : path to the local directory to
        transfer / be transferred to

    remote_filepath : path to the remote directory to
        transfer / be transferred to

    rclone_config_name : name of the rclone config that
        includes information on the target filesystem (e.g.
        ssh login details). This is managed by datashuttle
        e.g. setup_remote_as_rclone_target()

    upload_or_download : "upload" or "download" dictates
        direction of file transfer

    dry_run : if True, output will be as usual but no
        file will be transferred.
    """
    extra_arguments = handle_rclone_arguments(rclone_options)

    if upload_or_download == "upload":

        output = call_rclone(
            f"{rclone_args('copy')} "
            f'"{local_filepath}" "{rclone_config_name}:{remote_filepath}" {extra_arguments}',
            pipe_std=True,
        )

    elif upload_or_download == "download":

        output = call_rclone(
            f"{rclone_args('copy')} "
            f'"{rclone_config_name}:'
            f'{remote_filepath}" '
            f'"{local_filepath}"  '
            f"{extra_arguments}",
            pipe_std=True,
        )

    return output


def setup_remote_as_rclone_target(
    connection_method: str,
    cfg: Configs,
    rclone_config_name: str,
    ssh_key_path: Path,
    log: bool = False,
) -> None:
    """
    RClone sets remote targets in a config file. When
    copying to remote, use the syntax remote: to
    identify the remote to copy to.

    For local filesystem, this is just a placeholder and
    the config contains no further information.

    For SSH, this contains information for
    connecting to remote with SSH.

    Parameters
    ----------

    cfg : datashuttle configs UserDict

    rclone_config_name : rclone config name
        generated by datashuttle.cfg.get_rclone_config_name()

    ssh_key_path : path to the ssh key used for connecting to
        ssh remote filesystem, if config "connection_method" is "ssh"

    log : whether to log, if True logger must already be initialised.
    """
    if connection_method == "local_filesystem":
        call_rclone(f"config create {rclone_config_name} local", pipe_std=True)

    elif connection_method == "ssh":

        call_rclone(
            f"config create "
            f"{rclone_config_name} "
            f"sftp "
            f"host {cfg['remote_host_id']} "
            f"user {cfg['remote_host_username']} "
            f"port 22 "
            f"key_file {ssh_key_path.as_posix()}",
            pipe_std=True,
        )

    output = call_rclone("config file", pipe_std=True)

    if log:
        utils.log(
            f"Successfully created rclone config. "
            f"{output.stdout.decode('utf-8')}"
        )


def check_rclone_with_default_call() -> bool:
    """
    Check to see whether rclone is installed.
    """
    try:
        output = call_rclone("-h", pipe_std=True)
    except FileNotFoundError:
        return False
    return True if output.returncode == 0 else False


def prompt_rclone_download_if_does_not_exist() -> None:
    """
    Check that rclone is installed. If it does not
    (e.g. first time using datashuttle) then download.
    """
    if not check_rclone_with_default_call():
        raise BaseException(
            "RClone installation not found. Install by entering "
            "the following into your terminal:\n"
            " conda install -c conda-forge rclone"
        )


def rclone_args(name: str) -> str:
    """
    Central function to hold rclone commands
    """
    if name == "dry_run":
        arg = "--dry-run"

    if name == "create_empty_src_dirs":
        arg = "--create-empty-src-dirs"

    if name == "copy":
        arg = "copy"

    if name == "ignore_existing":
        arg = "--ignore-existing"

    if name == "progress":
        arg = "--progress"

    return arg
